import asyncHandler from 'express-async-handler';
import { prisma } from '../config/database.js';
import { successResponse } from '../utils/response.js';
import { NotFoundError } from '../utils/errors.js';
import { HTTP_STATUS, SUCCESS_MESSAGES } from '../config/constants.js';
import uploadService from '../services/upload.service.js';

/**
 * @route   GET /api/students
 * @desc    Get all students
 * @access  Private
 */
export const getAllStudents = asyncHandler(async (req, res) => {
  const students = await prisma.students.findMany({
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
    orderBy: { Student_ID: 'asc' },
  });

  // Return base64 strings as-is for response
  const studentsWithImages = students.map((student) => ({
    ...student,
    Face_Pictures: student.Face_Pictures || null,
  }));

  successResponse(res, studentsWithImages, 'Students retrieved successfully');
});

/**
 * @route   GET /api/students/:id
 * @desc    Get student by ID
 * @access  Private
 */
export const getStudentById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const student = await prisma.students.findUnique({
    where: { Student_ID: id },
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
      TimeTable: {
        select: {
          TimeTable_ID: true,
          EntryTime: true,
          ExitTime: true,
          zone: {
            select: {
              Zone_Name: true,
            },
          },
        },
        orderBy: { EntryTime: 'desc' },
        take: 10,
      },
    },
  });

  if (!student) {
    throw new NotFoundError(`Student with ID ${id} not found`);
  }

  // Convert Face_Pictures buffer to base64
  const studentWithBase64 = {
    ...student,
    Face_Pictures: student.Face_Pictures || null,
  };

  successResponse(res, studentWithBase64, 'Student retrieved successfully');
});

/**
 * @route   POST /api/students
 * @desc    Create new student with multiple face images
 * @access  Private
 */
export const createStudent = asyncHandler(async (req, res) => {
  const { Name, Email, Face_Pictures, Camara_Id, Zone_id } = req.body;
  // Defensive handling: Face_Pictures may be sent as base64 string(s) or Buffer(s)
  // Normalize to a single base64 string (first image) for storage
  let facePictureString = null;
  if (Face_Pictures) {
    // If a Buffer was sent directly (e.g., multipart handlers), convert to base64
    if (Buffer.isBuffer(Face_Pictures)) {
      facePictureString = uploadService.bufferToBase64(Face_Pictures);
      uploadService.validateImageSize(facePictureString);
    } else if (Array.isArray(Face_Pictures)) {
      // Array may contain base64 strings or Buffers
      if (Face_Pictures.length > 0) {
        const first = Face_Pictures[0];
        if (Buffer.isBuffer(first)) {
          facePictureString = uploadService.bufferToBase64(first);
        } else {
          facePictureString = first;
        }
        uploadService.validateImageSize(facePictureString);
      }
    } else {
      // Assume it's a base64 string
      facePictureString = Face_Pictures;
      uploadService.validateImageSize(facePictureString);
    }
  }

  const student = await prisma.students.create({
    data: {
      Name,
      Email,
      Face_Pictures: facePictureString,
      Camara_Id,
      Zone_id,
    },
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
  });

  // Generate face encodings asynchronously (don't wait for it)
  // Disabled temporarily to prevent timeout - face encodings will be generated by Python system
  if (Face_Pictures && false) {
    const { default: faceEncodingService } = await import('../services/faceEncoding.service.js');
    const images = Array.isArray(Face_Pictures) ? Face_Pictures : [Face_Pictures];
    faceEncodingService.generateEncodings('STUDENT', student.Student_ID, images)
      .then(result => {
        console.log(`Face encoding for student ${student.Student_ID}:`, result.message);
      })
      .catch(error => {
        console.error(`Face encoding error for student ${student.Student_ID}:`, error);
      });
  }

  // Return base64 string as-is for response
  const studentWithImages = {
    ...student,
    Face_Pictures: student.Face_Pictures || null,
  };

  successResponse(
    res,
    studentWithImages,
    SUCCESS_MESSAGES.CREATED,
    HTTP_STATUS.CREATED
  );
});

/**
 * @route   PUT /api/students/:id
 * @desc    Update student
 * @access  Private
 */
export const updateStudent = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { Name, Email, Face_Pictures, Camara_Id, Zone_id } = req.body;

  // Check if student exists
  const existingStudent = await prisma.students.findUnique({
    where: { Student_ID: id },
  });

  if (!existingStudent) {
    throw new NotFoundError(`Student with ID ${id} not found`);
  }

  const updateData = {};
  if (Name !== undefined) updateData.Name = Name;
  if (Email !== undefined) updateData.Email = Email;
  if (Camara_Id !== undefined) updateData.Camara_Id = Camara_Id;
  if (Zone_id !== undefined) updateData.Zone_id = Zone_id;

  // Convert base64 to buffer if provided
  if (Face_Pictures !== undefined) {
    if (Face_Pictures) {
      uploadService.validateImageSize(Face_Pictures);
      updateData.Face_Pictures = Face_Pictures;
    } else {
      updateData.Face_Pictures = null;
    }
  }

  const student = await prisma.students.update({
    where: { Student_ID: id },
    data: updateData,
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
  });

  // Convert buffer back to base64 for response
  const studentWithBase64 = {
    ...student,
    Face_Pictures: student.Face_Pictures || null,
  };

  successResponse(res, studentWithBase64, SUCCESS_MESSAGES.UPDATED);
});

/**
 * @route   DELETE /api/students/:id
 * @desc    Delete student
 * @access  Private
 */
export const deleteStudent = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Check if student exists
  const existingStudent = await prisma.students.findUnique({
    where: { Student_ID: id },
  });

  if (!existingStudent) {
    throw new NotFoundError(`Student with ID ${id} not found`);
  }

  await prisma.students.delete({
    where: { Student_ID: id },
  });

  successResponse(
    res,
    { Student_ID: id },
    SUCCESS_MESSAGES.DELETED,
    HTTP_STATUS.OK
  );
});

/**
 * @route   POST /api/students/:id/face-picture
 * @desc    Upload face picture for student
 * @access  Private
 */
export const uploadFacePicture = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { Face_Pictures } = req.body;

  // Check if student exists
  const existingStudent = await prisma.students.findUnique({
    where: { Student_ID: id },
  });

  if (!existingStudent) {
    throw new NotFoundError(`Student with ID ${id} not found`);
  }

  // Validate and store base64 string directly
  uploadService.validateImageSize(Face_Pictures);

  const student = await prisma.students.update({
    where: { Student_ID: id },
    data: { Face_Pictures },
    select: {
      Student_ID: true,
      Name: true,
      Email: true,
      Face_Pictures: true,
    },
  });

  // Return base64 string as-is for response
  const studentWithBase64 = {
    ...student,
    Face_Pictures: student.Face_Pictures || null,
  };

  successResponse(res, studentWithBase64, 'Face picture uploaded successfully');
});
