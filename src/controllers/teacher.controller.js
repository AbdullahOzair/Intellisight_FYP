import asyncHandler from 'express-async-handler';
import { prisma } from '../config/database.js';
import { successResponse } from '../utils/response.js';
import { NotFoundError } from '../utils/errors.js';
import { HTTP_STATUS, SUCCESS_MESSAGES } from '../config/constants.js';
import uploadService from '../services/upload.service.js';

/**
 * @route   GET /api/teachers
 * @desc    Get all teachers
 * @access  Private
 */
export const getAllTeachers = asyncHandler(async (req, res) => {
  const teachers = await prisma.teacher.findMany({
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
    orderBy: { Teacher_ID: 'asc' },
  });

  // Return base64 strings as-is for response
  const teachersWithImages = teachers.map((teacher) => ({
    ...teacher,
    Face_Pictures: teacher.Face_Pictures || null,
  }));

  successResponse(res, teachersWithImages, 'Teachers retrieved successfully');
});

/**
 * @route   GET /api/teachers/:id
 * @desc    Get teacher by ID
 * @access  Private
 */
export const getTeacherById = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const teacher = await prisma.teacher.findUnique({
    where: { Teacher_ID: id },
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
      TimeTable: {
        select: {
          TimeTable_ID: true,
          EntryTime: true,
          ExitTime: true,
          zone: {
            select: {
              Zone_Name: true,
            },
          },
        },
        orderBy: { EntryTime: 'desc' },
        take: 10,
      },
    },
  });

  if (!teacher) {
    throw new NotFoundError(`Teacher with ID ${id} not found`);
  }

  // Convert Face_Pictures buffer to base64
  const teacherWithBase64 = {
    ...teacher,
    Face_Pictures: teacher.Face_Pictures || null,
  };

  successResponse(res, teacherWithBase64, 'Teacher retrieved successfully');
});

/**
 * @route   POST /api/teachers
 * @desc    Create new teacher with multiple face images
 * @access  Private
 */
export const createTeacher = asyncHandler(async (req, res) => {
  const { Name, Email, Face_Pictures, Camara_Id, Zone_id } = req.body;

  // Handle multiple images (array of base64 strings)
  // For now, store only the first image as base64 string in database
  let facePictureString = null;
  if (Face_Pictures) {
    if (Buffer.isBuffer(Face_Pictures)) {
      facePictureString = uploadService.bufferToBase64(Face_Pictures);
      uploadService.validateImageSize(facePictureString);
    } else if (Array.isArray(Face_Pictures)) {
      if (Face_Pictures.length > 0) {
        const first = Face_Pictures[0];
        if (Buffer.isBuffer(first)) {
          facePictureString = uploadService.bufferToBase64(first);
        } else {
          facePictureString = first;
        }
        uploadService.validateImageSize(facePictureString);
      }
    } else {
      uploadService.validateImageSize(Face_Pictures);
      facePictureString = Face_Pictures;
    }
  }

  const teacher = await prisma.teacher.create({
    data: {
      Name,
      Email,
      Face_Pictures: facePictureString,
      Camara_Id,
      Zone_id,
    },
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
  });

  // Generate face encodings asynchronously (don't wait for it)
  // Disabled temporarily to prevent timeout - face encodings will be generated by Python system
  if (Face_Pictures && false) {
    const { default: faceEncodingService } = await import('../services/faceEncoding.service.js');
    const images = Array.isArray(Face_Pictures) ? Face_Pictures : [Face_Pictures];
    faceEncodingService.generateEncodings('TEACHER', teacher.Teacher_ID, images)
      .then(result => {
        console.log(`Face encoding for teacher ${teacher.Teacher_ID}:`, result.message);
      })
      .catch(error => {
        console.error(`Face encoding error for teacher ${teacher.Teacher_ID}:`, error);
      });
  }

  // Return base64 string as-is for response
  const teacherWithImages = {
    ...teacher,
    Face_Pictures: teacher.Face_Pictures || null,
  };

  successResponse(
    res,
    teacherWithImages,
    SUCCESS_MESSAGES.CREATED,
    HTTP_STATUS.CREATED
  );
});

/**
 * @route   PUT /api/teachers/:id
 * @desc    Update teacher
 * @access  Private
 */
export const updateTeacher = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { Name, Email, Face_Pictures, Camara_Id, Zone_id } = req.body;

  // Check if teacher exists
  const existingTeacher = await prisma.teacher.findUnique({
    where: { Teacher_ID: id },
  });

  if (!existingTeacher) {
    throw new NotFoundError(`Teacher with ID ${id} not found`);
  }

  const updateData = {};
  if (Name !== undefined) updateData.Name = Name;
  if (Email !== undefined) updateData.Email = Email;
  if (Camara_Id !== undefined) updateData.Camara_Id = Camara_Id;
  if (Zone_id !== undefined) updateData.Zone_id = Zone_id;

  // Convert base64 to buffer if provided
  if (Face_Pictures !== undefined) {
    if (Face_Pictures) {
      uploadService.validateImageSize(Face_Pictures);
      updateData.Face_Pictures = Face_Pictures;
    } else {
      updateData.Face_Pictures = null;
    }
  }

  const teacher = await prisma.teacher.update({
    where: { Teacher_ID: id },
    data: updateData,
    include: {
      zone: {
        select: {
          Zone_id: true,
          Zone_Name: true,
        },
      },
      camara: {
        select: {
          Camara_Id: true,
        },
      },
    },
  });

  // Convert buffer back to base64 for response
  const teacherWithBase64 = {
    ...teacher,
    Face_Pictures: teacher.Face_Pictures || null,
  };

  successResponse(res, teacherWithBase64, SUCCESS_MESSAGES.UPDATED);
});

/**
 * @route   DELETE /api/teachers/:id
 * @desc    Delete teacher
 * @access  Private
 */
export const deleteTeacher = asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Check if teacher exists
  const existingTeacher = await prisma.teacher.findUnique({
    where: { Teacher_ID: id },
  });

  if (!existingTeacher) {
    throw new NotFoundError(`Teacher with ID ${id} not found`);
  }

  await prisma.teacher.delete({
    where: { Teacher_ID: id },
  });

  successResponse(
    res,
    { Teacher_ID: id },
    SUCCESS_MESSAGES.DELETED,
    HTTP_STATUS.OK
  );
});

/**
 * @route   POST /api/teachers/:id/face-picture
 * @desc    Upload face picture for teacher
 * @access  Private
 */
export const uploadFacePicture = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { Face_Pictures } = req.body;

  // Check if teacher exists
  const existingTeacher = await prisma.teacher.findUnique({
    where: { Teacher_ID: id },
  });

  if (!existingTeacher) {
    throw new NotFoundError(`Teacher with ID ${id} not found`);
  }

  // Validate and accept base64 string
  uploadService.validateImageSize(Face_Pictures);

  const teacher = await prisma.teacher.update({
    where: { Teacher_ID: id },
    data: { Face_Pictures },
    select: {
      Teacher_ID: true,
      Name: true,
      Email: true,
      Face_Pictures: true,
    },
  });

  // Return base64 string as-is for response
  const teacherWithBase64 = {
    ...teacher,
    Face_Pictures: teacher.Face_Pictures || null,
  };

  successResponse(res, teacherWithBase64, 'Face picture uploaded successfully');
});
